{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://FileUploader/webpack/universalModuleDefinition","webpack://FileUploader/./src/sdk/FileUploader.ts","webpack://FileUploader/webpack/bootstrap","webpack://FileUploader/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FileUploader\"] = factory();\n\telse\n\t\troot[\"FileUploader\"] = factory();\n})(this, () => {\nreturn ","/**\r\n * Large File Upload SDK / 大文件上传SDK\r\n * Supports chunked upload, resumable upload, and instant transfer / 支持分片上传、断点续传和秒传\r\n */\r\n\r\n// 定义类型接口\r\ninterface FileUploaderOptions {\r\n  checkEndpoint: string;\r\n  chunkEndpoint: string;\r\n  mergeEndpoint: string;\r\n  chunkSize?: number;\r\n  concurrentFiles?: number;\r\n  concurrentChunks?: number;\r\n  maxRetries?: number;\r\n}\r\n\r\ninterface FileItem {\r\n  id: string;\r\n  file: File;\r\n  status: 'pending' | 'checking' | 'uploading' | 'merging' | 'success' | 'error' | 'cancelled';\r\n  progress: number;\r\n  name: string;\r\n  size: number;\r\n  uploadedChunks: number[];\r\n  totalChunks: number;\r\n  md5?: string;\r\n  error?: string;\r\n}\r\n\r\ninterface CheckFileResponse {\r\n  exists: boolean;\r\n  path?: string;\r\n  uploadedChunks: number[];\r\n}\r\n\r\ninterface MergeFileResponse {\r\n  success: boolean;\r\n  path?: string;\r\n}\r\n\r\nclass FileUploader {\r\n  // API endpoints (required) / API端点（必需）\r\n  private checkEndpoint: string;\r\n  private chunkEndpoint: string;\r\n  private mergeEndpoint: string;\r\n  \r\n  // Upload configuration / 上传配置\r\n  private chunkSize: number;\r\n  private concurrentFiles: number;\r\n  private concurrentChunks: number;\r\n  private maxRetries: number;\r\n  \r\n  private uploadQueue: FileItem[];\r\n  private uploadingCount: number;\r\n  private files: FileItem[];\r\n  \r\n  // 存储正在进行的请求控制器，用于取消上传\r\n  private abortControllers: Map<string, AbortController>;\r\n\r\n  /**\r\n   * Create a FileUploader instance / 创建一个FileUploader实例\r\n   * @param {Object} options - Configuration options / 配置选项\r\n   * @param {string} options.checkEndpoint - API endpoint for checking file status / 检查文件状态的API端点\r\n   * @param {string} options.chunkEndpoint - API endpoint for uploading chunks / 上传分片的API端点\r\n   * @param {string} options.mergeEndpoint - API endpoint for merging chunks / 合并分片的API端点\r\n   * @param {number} options.chunkSize - Size of each chunk in bytes (default: 2MB) / 每个分片的大小（默认：2MB）\r\n   * @param {number} options.concurrentFiles - Max concurrent file uploads (default: 3) / 最大并发文件上传数（默认：3）\r\n   * @param {number} options.concurrentChunks - Max concurrent chunk uploads per file (default: 3) / 每个文件的最大并发分片上传数（默认：3）\r\n   * @param {number} options.maxRetries - Max retry attempts for failed uploads (default: 3) / 上传失败的最大重试次数（默认：3）\r\n   */\r\n  constructor(options: FileUploaderOptions) {\r\n    // API endpoints (required) / API端点（必需）\r\n    this.checkEndpoint = options.checkEndpoint;\r\n    this.chunkEndpoint = options.chunkEndpoint;\r\n    this.mergeEndpoint = options.mergeEndpoint;\r\n    \r\n    // Validate required endpoints / 验证必需的端点\r\n    if (!this.checkEndpoint || !this.chunkEndpoint || !this.mergeEndpoint) {\r\n      throw new Error('All API endpoints (checkEndpoint, chunkEndpoint, mergeEndpoint) must be provided / 所有API端点（checkEndpoint、chunkEndpoint、mergeEndpoint）都必须提供');\r\n    }\r\n    \r\n    // Upload configuration / 上传配置\r\n    this.chunkSize = options.chunkSize || 2 * 1024 * 1024; // 2MB\r\n    this.concurrentFiles = options.concurrentFiles || 3;\r\n    this.concurrentChunks = options.concurrentChunks || 3;\r\n    this.maxRetries = options.maxRetries || 3;\r\n    \r\n    this.uploadQueue = [];\r\n    this.uploadingCount = 0;\r\n    this.files = [];\r\n    \r\n    // 存储正在进行的请求控制器，用于取消上传\r\n    this.abortControllers = new Map();\r\n  }\r\n\r\n  /**\r\n   * Add files to upload queue / 将文件添加到上传队列\r\n   * @param {FileList|File[]} fileList - Files to upload / 要上传的文件\r\n   */\r\n  addFiles(fileList: FileList | File[]): FileItem[] {\r\n    const newFiles: FileItem[] = Array.from(fileList).map((file) => ({\r\n      id: this.generateId(),\r\n      file,\r\n      status: 'pending', // pending, checking, uploading, merging, success, error, cancelled\r\n      progress: 0,\r\n      name: file.name,\r\n      size: file.size,\r\n      uploadedChunks: [],\r\n      totalChunks: Math.ceil(file.size / this.chunkSize),\r\n    }));\r\n\r\n    this.files = [...this.files, ...newFiles];\r\n    this.uploadQueue = [...this.uploadQueue, ...newFiles];\r\n    \r\n    this.processQueue();\r\n    \r\n    return newFiles;\r\n  }\r\n\r\n  /**\r\n   * Cancel file upload / 取消文件上传\r\n   * @param {string} fileId - ID of the file to cancel / 要取消的文件ID\r\n   */\r\n  cancelUpload(fileId: string): void {\r\n    const fileItem = this.files.find(item => item.id === fileId);\r\n    if (!fileItem) {\r\n      console.warn(`File with ID ${fileId} not found`);\r\n      return;\r\n    }\r\n\r\n    // 如果文件正在上传队列中，直接移除\r\n    if (fileItem.status === 'pending') {\r\n      this.uploadQueue = this.uploadQueue.filter(item => item.id !== fileId);\r\n      fileItem.status = 'cancelled';\r\n      this.updateFileStatus(fileItem);\r\n      return;\r\n    }\r\n\r\n    // 如果文件正在上传过程中，取消所有相关请求\r\n    if (fileItem.status === 'checking' || fileItem.status === 'uploading' || fileItem.status === 'merging') {\r\n      // 取消所有与该文件相关的请求\r\n      const abortController = this.abortControllers.get(fileId);\r\n      if (abortController) {\r\n        abortController.abort();\r\n        this.abortControllers.delete(fileId);\r\n      }\r\n      \r\n      fileItem.status = 'cancelled';\r\n      this.updateFileStatus(fileItem);\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process upload queue / 处理上传队列\r\n   */\r\n  private processQueue(): void {\r\n    while (this.uploadQueue.length > 0 && this.uploadingCount < this.concurrentFiles) {\r\n      const fileItem = this.uploadQueue.shift();\r\n      if (fileItem) {\r\n        this.uploadingCount++;\r\n        this.processFile(fileItem).then(() => {\r\n          this.uploadingCount--;\r\n          this.processQueue();\r\n        }).catch(() => {\r\n          this.uploadingCount--;\r\n          this.processQueue();\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process individual file / 处理单个文件\r\n   * @param {Object} fileItem - File item to process / 要处理的文件项\r\n   */\r\n  private async processFile(fileItem: FileItem): Promise<void> {\r\n    // 为每个文件创建 AbortController\r\n    const abortController = new AbortController();\r\n    this.abortControllers.set(fileItem.id, abortController);\r\n    \r\n    try {\r\n      fileItem.status = 'checking';\r\n      this.updateFileStatus(fileItem);\r\n\r\n      // Calculate file MD5 / 计算文件MD5\r\n      const md5 = await this.calculateMD5(fileItem.file);\r\n      fileItem.md5 = md5;\r\n\r\n      // Check with server if file already exists or has partial uploads / 检查服务器上是否已存在文件或有部分上传\r\n      const checkResult: CheckFileResponse = await this.checkFile(fileItem.md5!, fileItem.file.name, abortController.signal);\r\n\r\n      if (checkResult.exists) {\r\n        // Instant transfer - file already exists / 秒传 - 文件已存在\r\n        fileItem.status = 'success';\r\n        fileItem.progress = 100;\r\n        this.updateFileStatus(fileItem);\r\n        this.abortControllers.delete(fileItem.id);\r\n        return;\r\n      }\r\n\r\n      // Identify chunks that still need to be uploaded / 识别仍需上传的分片\r\n      const chunksToUpload = Array.from({ length: fileItem.totalChunks }, (_, i) => i)\r\n        .filter(i => !checkResult.uploadedChunks.includes(i));\r\n\r\n      fileItem.uploadedChunks = checkResult.uploadedChunks;\r\n\r\n      if (chunksToUpload.length === 0) {\r\n        // All chunks already uploaded, just merge / 所有分片已上传，只需合并\r\n        await this.mergeFile(fileItem.md5!, fileItem.file.name, fileItem.totalChunks, abortController.signal);\r\n        fileItem.status = 'success';\r\n        fileItem.progress = 100;\r\n        this.updateFileStatus(fileItem);\r\n        this.abortControllers.delete(fileItem.id);\r\n        return;\r\n      }\r\n\r\n      // Upload remaining chunks / 上传剩余分片\r\n      fileItem.status = 'uploading';\r\n      this.updateFileStatus(fileItem);\r\n      \r\n      await this.uploadChunksWithConcurrency(\r\n        fileItem,\r\n        chunksToUpload,\r\n        abortController.signal\r\n      );\r\n\r\n      // Merge chunks into final file / 将分片合并为最终文件\r\n      fileItem.status = 'merging';\r\n      this.updateFileStatus(fileItem);\r\n      \r\n      await this.mergeFile(fileItem.md5!, fileItem.file.name, fileItem.totalChunks, abortController.signal);\r\n      \r\n      fileItem.status = 'success';\r\n      fileItem.progress = 100;\r\n      this.updateFileStatus(fileItem);\r\n      this.abortControllers.delete(fileItem.id);\r\n    } catch (error: any) {\r\n      // 检查是否是由于取消上传导致的错误\r\n      if (error.name === 'AbortError') {\r\n        fileItem.status = 'cancelled';\r\n        this.updateFileStatus(fileItem);\r\n      } else {\r\n        fileItem.status = 'error';\r\n        fileItem.error = error.message;\r\n        this.updateFileStatus(fileItem);\r\n        console.error('Upload error:', error);\r\n      }\r\n      this.abortControllers.delete(fileItem.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Upload chunks with concurrency control / 并发控制上传分片\r\n   * @param {Object} fileItem - File item being uploaded / 正在上传的文件项\r\n   * @param {number[]} chunksToUpload - Indices of chunks to upload / 要上传的分片索引\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   */\r\n  private async uploadChunksWithConcurrency(fileItem: FileItem, chunksToUpload: number[], signal: AbortSignal): Promise<void> {\r\n    let index = 0;\r\n\r\n    const uploadChunk = async (chunkIndex: number): Promise<void> => {\r\n      // 检查是否已经取消\r\n      if (signal.aborted) {\r\n        throw new DOMException('Aborted', 'AbortError');\r\n      }\r\n      \r\n      const start = chunkIndex * this.chunkSize;\r\n      const end = Math.min(start + this.chunkSize, fileItem.file.size);\r\n      const chunk = fileItem.file.slice(start, end);\r\n\r\n      const formData = new FormData();\r\n      formData.append('file', chunk);\r\n      formData.append('md5', fileItem.md5!);\r\n      formData.append('chunkIndex', chunkIndex.toString());\r\n      formData.append('totalChunks', fileItem.totalChunks.toString());\r\n\r\n      await this.uploadWithRetry((signal) => {\r\n        return fetch(this.chunkEndpoint, {\r\n          method: 'POST',\r\n          body: formData,\r\n          signal: signal\r\n        });\r\n      }, this.maxRetries, signal);\r\n\r\n      // Update progress / 更新进度\r\n      fileItem.uploadedChunks.push(chunkIndex);\r\n      const progress = Math.round((fileItem.uploadedChunks.length / fileItem.totalChunks) * 100);\r\n      fileItem.progress = progress;\r\n      this.updateFileStatus(fileItem);\r\n    };\r\n\r\n    const workers = Array.from({ length: this.concurrentChunks }, async () => {\r\n      while (index < chunksToUpload.length && !signal.aborted) {\r\n        const chunkIndex = chunksToUpload[index];\r\n        index++;\r\n        await uploadChunk(chunkIndex);\r\n      }\r\n    });\r\n\r\n    await Promise.all(workers);\r\n    \r\n    // 如果被取消，抛出异常\r\n    if (signal.aborted) {\r\n      throw new DOMException('Aborted', 'AbortError');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check file status with server / 检查文件状态\r\n   * @param {string} md5 - File MD5 hash / 文件MD5哈希值\r\n   * @param {string} filename - Original filename / 原始文件名\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   * @returns {Promise<Object>} - Server response / 服务器响应\r\n   */\r\n  private async checkFile(md5: string, filename: string, signal: AbortSignal): Promise<CheckFileResponse> {\r\n    const response = await fetch(this.checkEndpoint, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ md5, filename }),\r\n      signal: signal\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n\r\n    return response.json();\r\n  }\r\n\r\n  /**\r\n   * Request server to merge chunks / 请求服务器合并分片\r\n   * @param {string} md5 - File MD5 hash / 文件MD5哈希值\r\n   * @param {string} filename - Original filename / 原始文件名\r\n   * @param {number} totalChunks - Total number of chunks / 分片总数\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   * @returns {Promise<Object>} - Server response / 服务器响应\r\n   */\r\n  private async mergeFile(md5: string, filename: string, totalChunks: number, signal: AbortSignal): Promise<MergeFileResponse> {\r\n    const response = await fetch(this.mergeEndpoint, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ md5, filename, totalChunks }),\r\n      signal: signal\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n\r\n    return response.json();\r\n  }\r\n\r\n  /**\r\n   * Upload with retry mechanism / 带重试机制的上传\r\n   * @param {Function} fn - Function to execute / 要执行的函数\r\n   * @param {number} maxRetries - Maximum retry attempts / 最大重试次数\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   * @returns {Promise<any>} - Result of function execution / 函数执行结果\r\n   */\r\n  private async uploadWithRetry(fn: (signal: AbortSignal) => Promise<Response>, maxRetries: number, signal: AbortSignal): Promise<Response> {\r\n    let lastError: any;\r\n\r\n    for (let i = 0; i <= maxRetries; i++) {\r\n      // 检查是否已经取消\r\n      if (signal.aborted) {\r\n        throw new DOMException('Aborted', 'AbortError');\r\n      }\r\n      \r\n      try {\r\n        const response = await fn(signal);\r\n        // 检查响应是否成功\r\n        if (!response.ok) {\r\n          throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        return response;\r\n      } catch (error: any) {\r\n        // 如果是取消操作导致的错误，立即抛出\r\n        if (error.name === 'AbortError') {\r\n          throw error;\r\n        }\r\n        \r\n        lastError = error;\r\n\r\n        if (i < maxRetries) {\r\n          // Exponential backoff delay / 指数退避延迟\r\n          const delay = Math.min(1000 * Math.pow(2, i), 10000);\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError;\r\n  }\r\n\r\n  /**\r\n   * Calculate MD5 of file using Web Worker / 使用Web Worker计算文件MD5\r\n   * @param {File} file - File to calculate MD5 for / 要计算MD5的文件\r\n   * @returns {Promise<string>} - MD5 hash / MD5哈希值\r\n   */\r\n  private async calculateMD5(file: File): Promise<string> {\r\n    // Check if Web Workers are supported / 检查是否支持Web Workers\r\n    if (typeof Worker !== 'undefined') {\r\n      return new Promise((resolve, reject) => {\r\n        try {\r\n          // Create Web Worker code / 创建Web Worker代码\r\n          const workerCode = `\r\n            self.onmessage = function(event) {\r\n              const { file, chunkSize = 2 * 1024 * 1024 } = event.data;\r\n              \r\n              try {\r\n                // Dynamically import SparkMD5 / 动态导入SparkMD5\r\n                importScripts('https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js');\r\n                \r\n                const spark = new SparkMD5.ArrayBuffer();\r\n                let currentChunk = 0;\r\n                const totalChunks = Math.ceil(file.size / chunkSize);\r\n\r\n                function loadNextChunk() {\r\n                  const start = currentChunk * chunkSize;\r\n                  const end = Math.min(start + chunkSize, file.size);\r\n                  const chunk = file.slice(start, end);\r\n                  \r\n                  const reader = new FileReader();\r\n                  reader.onload = function(e) {\r\n                    spark.append(e.target.result);\r\n                    currentChunk++;\r\n                    \r\n                    // Send progress update / 发送进度更新\r\n                    const progress = Math.round((currentChunk / totalChunks) * 100);\r\n                    self.postMessage({ progress, type: 'progress' });\r\n                    \r\n                    if (currentChunk < totalChunks) {\r\n                      loadNextChunk();\r\n                    } else {\r\n                      const md5 = spark.end();\r\n                      self.postMessage({ md5, success: true });\r\n                    }\r\n                  };\r\n                  \r\n                  reader.onerror = function(err) {\r\n                    self.postMessage({ error: 'Failed to read file chunk: ' + err.message, success: false });\r\n                  };\r\n                  \r\n                  reader.readAsArrayBuffer(chunk);\r\n                }\r\n                \r\n                loadNextChunk();\r\n              } catch (error) {\r\n                self.postMessage({ error: 'Worker error: ' + error.message, success: false });\r\n              }\r\n            };\r\n          `;\r\n          \r\n          // Create Blob URL / 创建Blob URL\r\n          const blob = new Blob([workerCode], { type: 'application/javascript' });\r\n          const workerUrl = URL.createObjectURL(blob);\r\n          \r\n          // Create Web Worker / 创建Web Worker\r\n          const worker = new Worker(workerUrl);\r\n          \r\n          // Send file to Worker / 发送文件到Worker\r\n          worker.postMessage({\r\n            file: file,\r\n            chunkSize: this.chunkSize\r\n          });\r\n          \r\n          // Listen for Worker messages / 监听Worker消息\r\n          worker.onmessage = function(event) {\r\n            const data = event.data;\r\n            \r\n            if (data.type === 'progress') {\r\n              // Handle progress updates / 处理进度更新\r\n              console.log('MD5 calculation progress: ' + data.progress + '%');\r\n            } else if (data.success) {\r\n              // MD5 calculation complete / MD5计算完成\r\n              URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\r\n              resolve(data.md5);\r\n              worker.terminate(); // Terminate Worker / 终止Worker\r\n            } else {\r\n              // MD5 calculation error / MD5计算错误\r\n              URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\r\n              reject(new Error(data.error));\r\n              worker.terminate(); // Terminate Worker / 终止Worker\r\n            }\r\n          };\r\n          \r\n          // Handle Worker errors / 处理Worker错误\r\n          worker.onerror = function(error) {\r\n            URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\r\n            reject(new Error('Worker error: ' + error.message));\r\n            worker.terminate(); // Terminate Worker / 终止Worker\r\n          };\r\n        } catch (error) {\r\n          // Fallback to main thread if Web Workers initialization fails / 如果Web Workers初始化失败则回退到主线程\r\n          console.warn('Failed to initialize Web Worker, falling back to main thread calculation / 无法初始化Web Worker，回退到主线程计算');\r\n          this.calculateMD5Fallback(file).then(resolve).catch(reject);\r\n        }\r\n      });\r\n    } else {\r\n      // Fallback to main thread if Web Workers are not supported / 如果不支持Web Workers则回退到主线程\r\n      console.warn('Web Workers not supported, falling back to main thread calculation / 不支持Web Workers，回退到主线程计算');\r\n      return this.calculateMD5Fallback(file);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fallback MD5 calculation on main thread / 在主线程中回退的MD5计算\r\n   * @param {File} file - File to calculate MD5 for / 要计算MD5的文件\r\n   * @returns {Promise<string>} - MD5 hash / MD5哈希值\r\n   */\r\n  private async calculateMD5Fallback(file: File): Promise<string> {\r\n    // Simulate MD5 calculation on main thread / 在主线程中模拟MD5计算\r\n    return new Promise((resolve) => {\r\n      // Simulate calculation time / 模拟计算时间\r\n      setTimeout(() => {\r\n        // Simplified MD5 simulation / 简化的MD5模拟\r\n        resolve('md5-' + Date.now() + '-' + file.name);\r\n      }, 300);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate unique ID / 生成唯一ID\r\n   * @returns {string} - Unique ID / 唯一ID\r\n   */\r\n  private generateId(): string {\r\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\r\n  }\r\n\r\n  /**\r\n   * Update file status callback / 更新文件状态回调\r\n   * Override this method to handle UI updates / 重写此方法以处理UI更新\r\n   * @param {Object} fileItem - Updated file item / 更新的文件项\r\n   */\r\n  updateFileStatus(fileItem: FileItem): void {\r\n    // This method should be overridden by the user / 此方法应由用户重写\r\n    console.log(`File ${fileItem.name}: ${fileItem.status} (${fileItem.progress}%)`);\r\n  }\r\n\r\n  /**\r\n   * Get current files / 获取当前文件\r\n   * @returns {Array} - Current files / 当前文件\r\n   */\r\n  getFiles(): FileItem[] {\r\n    return this.files;\r\n  }\r\n  \r\n  /**\r\n   * Clean up resources / 清理资源\r\n   */\r\n  destroy(): void {\r\n    // 取消所有正在进行的上传\r\n    for (const [fileId, controller] of this.abortControllers.entries()) {\r\n      controller.abort();\r\n    }\r\n    this.abortControllers.clear();\r\n    this.uploadQueue = [];\r\n    this.files = [];\r\n  }\r\n}\r\n\r\n// Export for both CommonJS and AMD / 为CommonJS和AMD导出\r\ndeclare const define: any; // 声明define变量以避免TypeScript报错\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = FileUploader;\r\n} else if (typeof define !== 'undefined' && define.amd) {\r\n  define(function() {\r\n    return FileUploader;\r\n  });\r\n} else {\r\n  // Export to global scope / 导出到全局作用域\r\n  // @ts-ignore\r\n  window.FileUploader = FileUploader;\r\n}\r\n\r\n// 同时也导出为默认导出，以兼容ES6模块系统\r\nexport default FileUploader;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(148);\n"],"names":["root","factory","exports","module","define","amd","this","FileUploader","constructor","options","checkEndpoint","chunkEndpoint","mergeEndpoint","Error","chunkSize","concurrentFiles","concurrentChunks","maxRetries","uploadQueue","uploadingCount","files","abortControllers","Map","addFiles","fileList","newFiles","Array","from","map","file","id","generateId","status","progress","name","size","uploadedChunks","totalChunks","Math","ceil","processQueue","cancelUpload","fileId","fileItem","find","item","filter","updateFileStatus","abortController","get","abort","delete","console","warn","length","shift","processFile","then","catch","AbortController","set","md5","calculateMD5","checkResult","checkFile","signal","exists","chunksToUpload","_","i","includes","mergeFile","uploadChunksWithConcurrency","error","message","index","uploadChunk","async","chunkIndex","aborted","DOMException","start","end","min","chunk","slice","formData","FormData","append","toString","uploadWithRetry","fetch","method","body","push","round","workers","Promise","all","filename","response","headers","JSON","stringify","ok","json","fn","lastError","delay","pow","resolve","setTimeout","Worker","reject","blob","Blob","type","workerUrl","URL","createObjectURL","worker","postMessage","onmessage","event","data","log","success","revokeObjectURL","terminate","onerror","calculateMD5Fallback","Date","now","random","substr","getFiles","destroy","controller","entries","clear","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"ignoreList":[],"sourceRoot":""}
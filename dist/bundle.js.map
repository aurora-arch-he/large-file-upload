{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://FileUploader/webpack/universalModuleDefinition","webpack://FileUploader/./src/sdk/FileUploader.ts","webpack://FileUploader/webpack/bootstrap","webpack://FileUploader/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FileUploader\"] = factory();\n\telse\n\t\troot[\"FileUploader\"] = factory();\n})(this, () => {\nreturn ","/**\r\n * Large File Upload SDK / 大文件上传SDK\r\n * Supports chunked upload, resumable upload, and instant transfer / 支持分片上传、断点续传和秒传\r\n */\r\n\r\n// 定义类型接口\r\ninterface FileUploaderOptions {\r\n  /**\r\n   * 每个分片的大小（以字节为单位）\r\n   * Size of each chunk in bytes\r\n   * @default 2 * 1024 * 1024 (2MB)\r\n   */\r\n  chunkSize?: number;\r\n  \r\n  /**\r\n   * 最大同时上传的文件数量\r\n   * Max concurrent file uploads\r\n   * @default 3\r\n   */\r\n  concurrentFiles?: number;\r\n  \r\n  /**\r\n   * 每个文件最大同时上传的分片数量\r\n   * Max concurrent chunk uploads per file\r\n   * @default 3\r\n   */\r\n  concurrentChunks?: number;\r\n  \r\n  /**\r\n   * 请求失败时的最大重试次数\r\n   * Max retry attempts for failed uploads\r\n   * @default 3\r\n   */\r\n  maxRetries?: number;\r\n  \r\n  /**\r\n   * 用于检查文件状态的函数\r\n   * Function to check file status\r\n   * @param md5 - 文件的MD5值 / File MD5 hash\r\n   * @param filename - 原始文件名 / Original filename\r\n   * @returns Promise<CheckFileResponse> - 服务器响应 / Server response\r\n   */\r\n  checkFileFunction: (md5: string, filename: string) => Promise<CheckFileResponse>;\r\n  \r\n  /**\r\n   * 用于上传文件分片的函数\r\n   * Function to upload chunk\r\n   * @param formData - 包含分片数据的FormData对象 / Form data containing chunk\r\n   * @returns Promise<Response> - 服务器响应 / Server response\r\n   */\r\n  uploadChunkFunction: (formData: FormData) => Promise<Response>;\r\n  \r\n  /**\r\n   * 用于通知服务器合并文件分片的函数\r\n   * Function to merge chunks\r\n   * @param md5 - 文件的MD5值 / File MD5 hash\r\n   * @param filename - 原始文件名 / Original filename\r\n   * @param totalChunks - 总分片数 / Total number of chunks\r\n   * @returns Promise<MergeFileResponse> - 服务器响应 / Server response\r\n   */\r\n  mergeFileFunction: (md5: string, filename: string, totalChunks: number) => Promise<MergeFileResponse>;\r\n}\r\n\r\n/**\r\n * 文件项接口\r\n * File item interface\r\n */\r\ninterface FileItem {\r\n  /**\r\n   * 文件唯一标识符\r\n   * Unique identifier for the file\r\n   */\r\n  id: string;\r\n  \r\n  /**\r\n   * 原始File对象\r\n   * Original File object\r\n   */\r\n  file: File;\r\n  \r\n  /**\r\n   * 文件上传状态\r\n   * File upload status\r\n   */\r\n  status: 'pending' | 'checking' | 'uploading' | 'merging' | 'success' | 'error' | 'cancelled';\r\n  \r\n  /**\r\n   * 上传进度百分比\r\n   * Upload progress percentage\r\n   */\r\n  progress: number;\r\n  \r\n  /**\r\n   * 文件名\r\n   * File name\r\n   */\r\n  name: string;\r\n  \r\n  /**\r\n   * 文件大小（字节）\r\n   * File size in bytes\r\n   */\r\n  size: number;\r\n  \r\n  /**\r\n   * 已上传的分片索引数组\r\n   * Array of uploaded chunk indices\r\n   */\r\n  uploadedChunks: number[];\r\n  \r\n  /**\r\n   * 总分片数\r\n   * Total number of chunks\r\n   */\r\n  totalChunks: number;\r\n  \r\n  /**\r\n   * 文件的MD5值\r\n   * MD5 hash of the file\r\n   */\r\n  md5?: string;\r\n  \r\n  /**\r\n   * 错误信息（如果有）\r\n   * Error message (if any)\r\n   */\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * 检查文件响应接口\r\n * Check file response interface\r\n */\r\ninterface CheckFileResponse {\r\n  /**\r\n   * 文件是否已存在（用于秒传）\r\n   * Whether the file already exists (for instant transfer)\r\n   */\r\n  exists: boolean;\r\n  \r\n  /**\r\n   * 文件路径（仅当 exists=true 时）\r\n   * File path (only when exists=true)\r\n   */\r\n  path?: string;\r\n  \r\n  /**\r\n   * 已上传的分片索引数组（仅当 exists=false 时）\r\n   * Array of uploaded chunk indices (only when exists=false)\r\n   */\r\n  uploadedChunks: number[];\r\n}\r\n\r\n/**\r\n * 合并文件响应接口\r\n * Merge file response interface\r\n */\r\ninterface MergeFileResponse {\r\n  /**\r\n   * 合并操作是否成功\r\n   * Whether the merge operation was successful\r\n   */\r\n  success: boolean;\r\n  \r\n  /**\r\n   * 合并后的文件路径（仅当 success=true 时）\r\n   * Path of the merged file (only when success=true)\r\n   */\r\n  path?: string;\r\n}\r\n\r\nclass FileUploader {\r\n  // API endpoints (required) / API端点（必需）\r\n  private checkFileFunction: (md5: string, filename: string) => Promise<CheckFileResponse>;\r\n  private uploadChunkFunction: (formData: FormData) => Promise<Response>;\r\n  private mergeFileFunction: (md5: string, filename: string, totalChunks: number) => Promise<MergeFileResponse>;\r\n  \r\n  // Upload configuration / 上传配置\r\n  private chunkSize: number;\r\n  private concurrentFiles: number;\r\n  private concurrentChunks: number;\r\n  private maxRetries: number;\r\n  \r\n  private uploadQueue: FileItem[];\r\n  private uploadingCount: number;\r\n  private files: FileItem[];\r\n  \r\n  // 存储正在进行的请求控制器，用于取消上传\r\n  private abortControllers: Map<string, AbortController>;\r\n\r\n  /**\r\n   * Create a FileUploader instance / 创建一个FileUploader实例\r\n   * @param {Object} options - Configuration options / 配置选项\r\n   * @param {number} options.chunkSize - Size of each chunk in bytes (default: 2MB) / 每个分片的大小（默认：2MB）\r\n   * @param {number} options.concurrentFiles - Max concurrent file uploads (default: 3) / 最大并发文件上传数（默认：3）\r\n   * @param {number} options.concurrentChunks - Max concurrent chunk uploads per file (default: 3) / 每个文件的最大并发分片上传数（默认：3）\r\n   * @param {number} options.maxRetries - Max retry attempts for failed uploads (default: 3) / 上传失败的最大重试次数（默认：3）\r\n   * @param {Function} options.checkFileFunction - Function to check file status (required) / 检查文件状态的函数（必需）\r\n   * @param {Function} options.uploadChunkFunction - Function to upload chunk (required) / 上传分片的函数（必需）\r\n   * @param {Function} options.mergeFileFunction - Function to merge chunks (required) / 合并分片的函数（必需）\r\n   */\r\n  constructor(options: FileUploaderOptions) {\r\n    // Validate required functions\r\n    if (!options.checkFileFunction || !options.uploadChunkFunction || !options.mergeFileFunction) {\r\n      throw new Error('All custom functions (checkFileFunction, uploadChunkFunction, mergeFileFunction) must be provided');\r\n    }\r\n    \r\n    // API endpoints (required) / API端点（必需）\r\n    this.checkFileFunction = options.checkFileFunction;\r\n    this.uploadChunkFunction = options.uploadChunkFunction;\r\n    this.mergeFileFunction = options.mergeFileFunction;\r\n    \r\n    // Upload configuration / 上传配置\r\n    this.chunkSize = options.chunkSize || 2 * 1024 * 1024; // 2MB\r\n    this.concurrentFiles = options.concurrentFiles || 3;\r\n    this.concurrentChunks = options.concurrentChunks || 3;\r\n    this.maxRetries = options.maxRetries || 3;\r\n    \r\n    this.uploadQueue = [];\r\n    this.uploadingCount = 0;\r\n    this.files = [];\r\n    \r\n    // 存储正在进行的请求控制器，用于取消上传\r\n    this.abortControllers = new Map();\r\n  }\r\n\r\n  /**\r\n   * Add files to upload queue / 将文件添加到上传队列\r\n   * @param {FileList|File[]} fileList - Files to upload / 要上传的文件\r\n   */\r\n  addFiles(fileList: FileList | File[]): FileItem[] {\r\n    const newFiles: FileItem[] = Array.from(fileList).map((file) => ({\r\n      id: this.generateId(),\r\n      file,\r\n      status: 'pending', // pending, checking, uploading, merging, success, error, cancelled\r\n      progress: 0,\r\n      name: file.name,\r\n      size: file.size,\r\n      uploadedChunks: [],\r\n      totalChunks: Math.ceil(file.size / this.chunkSize),\r\n    }));\r\n\r\n    this.files = [...this.files, ...newFiles];\r\n    this.uploadQueue = [...this.uploadQueue, ...newFiles];\r\n    \r\n    this.processQueue();\r\n    \r\n    return newFiles;\r\n  }\r\n\r\n  /**\r\n   * Cancel file upload / 取消文件上传\r\n   * @param {string} fileId - ID of the file to cancel / 要取消的文件ID\r\n   */\r\n  cancelUpload(fileId: string): void {\r\n    const fileItem = this.files.find(item => item.id === fileId);\r\n    if (!fileItem) {\r\n      console.warn(`File with ID ${fileId} not found`);\r\n      return;\r\n    }\r\n\r\n    // 如果文件正在上传队列中，直接移除\r\n    if (fileItem.status === 'pending') {\r\n      this.uploadQueue = this.uploadQueue.filter(item => item.id !== fileId);\r\n      fileItem.status = 'cancelled';\r\n      this.updateFileStatus(fileItem);\r\n      return;\r\n    }\r\n\r\n    // 如果文件正在上传过程中，取消所有相关请求\r\n    if (fileItem.status === 'checking' || fileItem.status === 'uploading' || fileItem.status === 'merging') {\r\n      // 取消所有与该文件相关的请求\r\n      const abortController = this.abortControllers.get(fileId);\r\n      if (abortController) {\r\n        abortController.abort();\r\n        this.abortControllers.delete(fileId);\r\n      }\r\n      \r\n      fileItem.status = 'cancelled';\r\n      this.updateFileStatus(fileItem);\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process upload queue / 处理上传队列\r\n   */\r\n  private processQueue(): void {\r\n    while (this.uploadQueue.length > 0 && this.uploadingCount < this.concurrentFiles) {\r\n      const fileItem = this.uploadQueue.shift();\r\n      if (fileItem) {\r\n        this.uploadingCount++;\r\n        this.processFile(fileItem).then(() => {\r\n          this.uploadingCount--;\r\n          this.processQueue();\r\n        }).catch(() => {\r\n          this.uploadingCount--;\r\n          this.processQueue();\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process individual file / 处理单个文件\r\n   * @param {Object} fileItem - File item to process / 要处理的文件项\r\n   */\r\n  private async processFile(fileItem: FileItem): Promise<void> {\r\n    // 为每个文件创建 AbortController\r\n    const abortController = new AbortController();\r\n    this.abortControllers.set(fileItem.id, abortController);\r\n    \r\n    try {\r\n      fileItem.status = 'checking';\r\n      this.updateFileStatus(fileItem);\r\n\r\n      // Calculate file MD5 / 计算文件MD5\r\n      const md5 = await this.calculateMD5(fileItem.file);\r\n      fileItem.md5 = md5;\r\n\r\n      // Check with server if file already exists or has partial uploads / 检查服务器上是否已存在文件或有部分上传\r\n      const checkResult: CheckFileResponse = await this.checkFileFunction(fileItem.md5!, fileItem.file.name);\r\n\r\n      if (checkResult.exists) {\r\n        // Instant transfer - file already exists / 秒传 - 文件已存在\r\n        fileItem.status = 'success';\r\n        fileItem.progress = 100;\r\n        this.updateFileStatus(fileItem);\r\n        this.abortControllers.delete(fileItem.id);\r\n        return;\r\n      }\r\n\r\n      // Identify chunks that still need to be uploaded / 识别仍需上传的分片\r\n      const chunksToUpload = Array.from({ length: fileItem.totalChunks }, (_, i) => i)\r\n        .filter(i => !checkResult.uploadedChunks.includes(i));\r\n\r\n      fileItem.uploadedChunks = checkResult.uploadedChunks;\r\n\r\n      if (chunksToUpload.length === 0) {\r\n        // All chunks already uploaded, just merge / 所有分片已上传，只需合并\r\n        await this.mergeFileFunction(fileItem.md5!, fileItem.file.name, fileItem.totalChunks);\r\n        fileItem.status = 'success';\r\n        fileItem.progress = 100;\r\n        this.updateFileStatus(fileItem);\r\n        this.abortControllers.delete(fileItem.id);\r\n        return;\r\n      }\r\n\r\n      // Upload remaining chunks / 上传剩余分片\r\n      fileItem.status = 'uploading';\r\n      this.updateFileStatus(fileItem);\r\n      \r\n      await this.uploadChunksWithConcurrency(\r\n        fileItem,\r\n        chunksToUpload,\r\n        abortController.signal\r\n      );\r\n\r\n      // Merge chunks into final file / 将分片合并为最终文件\r\n      fileItem.status = 'merging';\r\n      this.updateFileStatus(fileItem);\r\n      \r\n      await this.mergeFileFunction(fileItem.md5!, fileItem.file.name, fileItem.totalChunks);\r\n      \r\n      fileItem.status = 'success';\r\n      fileItem.progress = 100;\r\n      this.updateFileStatus(fileItem);\r\n      this.abortControllers.delete(fileItem.id);\r\n    } catch (error: any) {\r\n      // 检查是否是由于取消上传导致的错误\r\n      if (error.name === 'AbortError') {\r\n        fileItem.status = 'cancelled';\r\n        this.updateFileStatus(fileItem);\r\n      } else {\r\n        fileItem.status = 'error';\r\n        fileItem.error = error.message;\r\n        this.updateFileStatus(fileItem);\r\n        console.error('Upload error:', error);\r\n      }\r\n      this.abortControllers.delete(fileItem.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Upload chunks with concurrency control / 并发控制上传分片\r\n   * @param {Object} fileItem - File item being uploaded / 正在上传的文件项\r\n   * @param {number[]} chunksToUpload - Indices of chunks to upload / 要上传的分片索引\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   */\r\n  private async uploadChunksWithConcurrency(fileItem: FileItem, chunksToUpload: number[], signal: AbortSignal): Promise<void> {\r\n    let index = 0;\r\n\r\n    const uploadChunk = async (chunkIndex: number): Promise<void> => {\r\n      // 检查是否已经取消\r\n      if (signal.aborted) {\r\n        throw new DOMException('Aborted', 'AbortError');\r\n      }\r\n      \r\n      const start = chunkIndex * this.chunkSize;\r\n      const end = Math.min(start + this.chunkSize, fileItem.file.size);\r\n      const chunk = fileItem.file.slice(start, end);\r\n\r\n      const formData = new FormData();\r\n      formData.append('file', chunk);\r\n      formData.append('md5', fileItem.md5!);\r\n      formData.append('chunkIndex', chunkIndex.toString());\r\n      formData.append('totalChunks', fileItem.totalChunks.toString());\r\n\r\n      await this.uploadWithRetry(async (signal) => {\r\n        // Check if the operation was aborted before calling the function\r\n        if (signal.aborted) {\r\n          throw new DOMException('Aborted', 'AbortError');\r\n        }\r\n        \r\n        return this.uploadChunkFunction(formData);\r\n      }, this.maxRetries, signal);\r\n\r\n      // Update progress / 更新进度\r\n      fileItem.uploadedChunks.push(chunkIndex);\r\n      const progress = Math.round((fileItem.uploadedChunks.length / fileItem.totalChunks) * 100);\r\n      fileItem.progress = progress;\r\n      this.updateFileStatus(fileItem);\r\n    };\r\n\r\n    const workers = Array.from({ length: this.concurrentChunks }, async () => {\r\n      while (index < chunksToUpload.length && !signal.aborted) {\r\n        const chunkIndex = chunksToUpload[index];\r\n        index++;\r\n        await uploadChunk(chunkIndex);\r\n      }\r\n    });\r\n\r\n    await Promise.all(workers);\r\n    \r\n    // 如果被取消，抛出异常\r\n    if (signal.aborted) {\r\n      throw new DOMException('Aborted', 'AbortError');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check file status with server / 检查文件状态\r\n   * @param {string} md5 - File MD5 hash / 文件MD5哈希值\r\n   * @param {string} filename - Original filename / 原始文件名\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   * @returns {Promise<Object>} - Server response / 服务器响应\r\n   */\r\n  private async checkFile(md5: string, filename: string, signal: AbortSignal): Promise<CheckFileResponse> {\r\n    // Wrap the checkFileFunction to support signal\r\n    const result = await this.checkFileFunction(md5, filename);\r\n    \r\n    // Check if the operation was aborted\r\n    if (signal.aborted) {\r\n      throw new DOMException('Aborted', 'AbortError');\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Request server to merge chunks / 请求服务器合并分片\r\n   * @param {string} md5 - File MD5 hash / 文件MD5哈希值\r\n   * @param {string} filename - Original filename / 原始文件名\r\n   * @param {number} totalChunks - Total number of chunks / 分片总数\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   * @returns {Promise<Object>} - Server response / 服务器响应\r\n   */\r\n  private async mergeFile(md5: string, filename: string, totalChunks: number, signal: AbortSignal): Promise<MergeFileResponse> {\r\n    // Wrap the mergeFileFunction to support signal\r\n    const result = await this.mergeFileFunction(md5, filename, totalChunks);\r\n    \r\n    // Check if the operation was aborted\r\n    if (signal.aborted) {\r\n      throw new DOMException('Aborted', 'AbortError');\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Upload with retry mechanism / 带重试机制的上传\r\n   * @param {Function} fn - Function to execute / 要执行的函数\r\n   * @param {number} maxRetries - Maximum retry attempts / 最大重试次数\r\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\r\n   * @returns {Promise<any>} - Result of function execution / 函数执行结果\r\n   */\r\n  private async uploadWithRetry(fn: (signal: AbortSignal) => Promise<Response>, maxRetries: number, signal: AbortSignal): Promise<Response> {\r\n    let lastError: any;\r\n\r\n    for (let i = 0; i <= maxRetries; i++) {\r\n      // 检查是否已经取消\r\n      if (signal.aborted) {\r\n        throw new DOMException('Aborted', 'AbortError');\r\n      }\r\n      \r\n      try {\r\n        const response = await fn(signal);\r\n        // 检查响应是否成功\r\n        if (!response.ok) {\r\n          throw new Error(`HTTP error! status: ${response.status}`);\r\n        }\r\n        return response;\r\n      } catch (error: any) {\r\n        // 如果是取消操作导致的错误，立即抛出\r\n        if (error.name === 'AbortError') {\r\n          throw error;\r\n        }\r\n        \r\n        lastError = error;\r\n\r\n        if (i < maxRetries) {\r\n          // Exponential backoff delay / 指数退避延迟\r\n          const delay = Math.min(1000 * Math.pow(2, i), 10000);\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError;\r\n  }\r\n\r\n  /**\r\n   * Calculate MD5 of file using Web Worker / 使用Web Worker计算文件MD5\r\n   * @param {File} file - File to calculate MD5 for / 要计算MD5的文件\r\n   * @returns {Promise<string>} - MD5 hash / MD5哈希值\r\n   */\r\n  private async calculateMD5(file: File): Promise<string> {\r\n    // Check if Web Workers are supported / 检查是否支持Web Workers\r\n    if (typeof Worker !== 'undefined') {\r\n      return new Promise((resolve, reject) => {\r\n        try {\r\n          // Create Web Worker code / 创建Web Worker代码\r\n          const workerCode = `\r\n            self.onmessage = function(event) {\r\n              const { file, chunkSize = 2 * 1024 * 1024 } = event.data;\r\n              \r\n              try {\r\n                // Dynamically import SparkMD5 / 动态导入SparkMD5\r\n                importScripts('https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js');\r\n                \r\n                const spark = new SparkMD5.ArrayBuffer();\r\n                let currentChunk = 0;\r\n                const totalChunks = Math.ceil(file.size / chunkSize);\r\n\r\n                function loadNextChunk() {\r\n                  const start = currentChunk * chunkSize;\r\n                  const end = Math.min(start + chunkSize, file.size);\r\n                  const chunk = file.slice(start, end);\r\n                  \r\n                  const reader = new FileReader();\r\n                  reader.onload = function(e) {\r\n                    spark.append(e.target.result);\r\n                    currentChunk++;\r\n                    \r\n                    // Send progress update / 发送进度更新\r\n                    const progress = Math.round((currentChunk / totalChunks) * 100);\r\n                    self.postMessage({ progress, type: 'progress' });\r\n                    \r\n                    if (currentChunk < totalChunks) {\r\n                      loadNextChunk();\r\n                    } else {\r\n                      const md5 = spark.end();\r\n                      self.postMessage({ md5, success: true });\r\n                    }\r\n                  };\r\n                  \r\n                  reader.onerror = function(err) {\r\n                    self.postMessage({ error: 'Failed to read file chunk: ' + err.message, success: false });\r\n                  };\r\n                  \r\n                  reader.readAsArrayBuffer(chunk);\r\n                }\r\n                \r\n                loadNextChunk();\r\n              } catch (error) {\r\n                self.postMessage({ error: 'Worker error: ' + error.message, success: false });\r\n              }\r\n            };\r\n          `;\r\n          \r\n          // Create Blob URL / 创建Blob URL\r\n          const blob = new Blob([workerCode], { type: 'application/javascript' });\r\n          const workerUrl = URL.createObjectURL(blob);\r\n          \r\n          // Create Web Worker / 创建Web Worker\r\n          const worker = new Worker(workerUrl);\r\n          \r\n          // Send file to Worker / 发送文件到Worker\r\n          worker.postMessage({\r\n            file: file,\r\n            chunkSize: this.chunkSize\r\n          });\r\n          \r\n          // Listen for Worker messages / 监听Worker消息\r\n          worker.onmessage = function(event) {\r\n            const data = event.data;\r\n            \r\n            if (data.type === 'progress') {\r\n              // Handle progress updates / 处理进度更新\r\n              console.log('MD5 calculation progress: ' + data.progress + '%');\r\n            } else if (data.success) {\r\n              // MD5 calculation complete / MD5计算完成\r\n              URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\r\n              resolve(data.md5);\r\n              worker.terminate(); // Terminate Worker / 终止Worker\r\n            } else {\r\n              // MD5 calculation error / MD5计算错误\r\n              URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\r\n              reject(new Error(data.error));\r\n              worker.terminate(); // Terminate Worker / 终止Worker\r\n            }\r\n          };\r\n          \r\n          // Handle Worker errors / 处理Worker错误\r\n          worker.onerror = function(error) {\r\n            URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\r\n            reject(new Error('Worker error: ' + error.message));\r\n            worker.terminate(); // Terminate Worker / 终止Worker\r\n          };\r\n        } catch (error) {\r\n          // Fallback to main thread if Web Workers initialization fails / 如果Web Workers初始化失败则回退到主线程\r\n          console.warn('Failed to initialize Web Worker, falling back to main thread calculation / 无法初始化Web Worker，回退到主线程计算');\r\n          this.calculateMD5Fallback(file).then(resolve).catch(reject);\r\n        }\r\n      });\r\n    } else {\r\n      // Fallback to main thread if Web Workers are not supported / 如果不支持Web Workers则回退到主线程\r\n      console.warn('Web Workers not supported, falling back to main thread calculation / 不支持Web Workers，回退到主线程计算');\r\n      return this.calculateMD5Fallback(file);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fallback MD5 calculation on main thread / 在主线程中回退的MD5计算\r\n   * @param {File} file - File to calculate MD5 for / 要计算MD5的文件\r\n   * @returns {Promise<string>} - MD5 hash / MD5哈希值\r\n   */\r\n  private async calculateMD5Fallback(file: File): Promise<string> {\r\n    // Simulate MD5 calculation on main thread / 在主线程中模拟MD5计算\r\n    return new Promise((resolve) => {\r\n      // Simulate calculation time / 模拟计算时间\r\n      setTimeout(() => {\r\n        // Simplified MD5 simulation / 简化的MD5模拟\r\n        resolve('md5-' + Date.now() + '-' + file.name);\r\n      }, 300);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate unique ID / 生成唯一ID\r\n   * @returns {string} - Unique ID / 唯一ID\r\n   */\r\n  private generateId(): string {\r\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\r\n  }\r\n\r\n  /**\r\n   * Update file status callback / 更新文件状态回调\r\n   * Override this method to handle UI updates / 重写此方法以处理UI更新\r\n   * @param {Object} fileItem - Updated file item / 更新的文件项\r\n   */\r\n  updateFileStatus(fileItem: FileItem): void {\r\n    // This method should be overridden by the user / 此方法应由用户重写\r\n    console.log(`File ${fileItem.name}: ${fileItem.status} (${fileItem.progress}%)`);\r\n  }\r\n\r\n  /**\r\n   * Get current files / 获取当前文件\r\n   * @returns {Array} - Current files / 当前文件\r\n   */\r\n  getFiles(): FileItem[] {\r\n    return this.files;\r\n  }\r\n  \r\n  /**\r\n   * Clean up resources / 清理资源\r\n   */\r\n  destroy(): void {\r\n    // 取消所有正在进行的上传\r\n    for (const [fileId, controller] of this.abortControllers.entries()) {\r\n      controller.abort();\r\n    }\r\n    this.abortControllers.clear();\r\n    this.uploadQueue = [];\r\n    this.files = [];\r\n  }\r\n\r\n}\r\n\r\n// Export for both CommonJS and AMD / 为CommonJS和AMD导出\r\ndeclare const define: any; // 声明define变量以避免TypeScript报错\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = FileUploader;\r\n} else if (typeof define !== 'undefined' && define.amd) {\r\n  define(function() {\r\n    return FileUploader;\r\n  });\r\n} else {\r\n  // Export to global scope / 导出到全局作用域\r\n  // @ts-ignore\r\n  window.FileUploader = FileUploader;\r\n}\r\n\r\n// 同时也导出为默认导出，以兼容ES6模块系统\r\nexport default FileUploader;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(148);\n"],"names":["root","factory","exports","module","define","amd","this","FileUploader","constructor","options","checkFileFunction","uploadChunkFunction","mergeFileFunction","Error","chunkSize","concurrentFiles","concurrentChunks","maxRetries","uploadQueue","uploadingCount","files","abortControllers","Map","addFiles","fileList","newFiles","Array","from","map","file","id","generateId","status","progress","name","size","uploadedChunks","totalChunks","Math","ceil","processQueue","cancelUpload","fileId","fileItem","find","item","filter","updateFileStatus","abortController","get","abort","delete","console","warn","length","shift","processFile","then","catch","AbortController","set","md5","calculateMD5","checkResult","exists","chunksToUpload","_","i","includes","uploadChunksWithConcurrency","signal","error","message","index","uploadChunk","async","chunkIndex","aborted","DOMException","start","end","min","chunk","slice","formData","FormData","append","toString","uploadWithRetry","push","round","workers","Promise","all","checkFile","filename","result","mergeFile","fn","lastError","response","ok","delay","pow","resolve","setTimeout","Worker","reject","blob","Blob","type","workerUrl","URL","createObjectURL","worker","postMessage","onmessage","event","data","log","success","revokeObjectURL","terminate","onerror","calculateMD5Fallback","Date","now","random","substr","getFiles","destroy","controller","entries","clear","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"ignoreList":[],"sourceRoot":""}
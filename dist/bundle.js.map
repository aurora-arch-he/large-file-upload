{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://FileUploader/webpack/universalModuleDefinition","webpack://FileUploader/./src/sdk/FileUploader.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FileUploader\"] = factory();\n\telse\n\t\troot[\"FileUploader\"] = factory();\n})(this, () => {\nreturn ","/**\n * Large File Upload SDK / 大文件上传SDK\n * Supports chunked upload, resumable upload, and instant transfer / 支持分片上传、断点续传和秒传\n */\n\n// 定义类型接口\ninterface FileUploaderOptions {\n  checkEndpoint: string;\n  chunkEndpoint: string;\n  mergeEndpoint: string;\n  chunkSize?: number;\n  concurrentFiles?: number;\n  concurrentChunks?: number;\n  maxRetries?: number;\n}\n\ninterface FileItem {\n  id: string;\n  file: File;\n  status: 'pending' | 'checking' | 'uploading' | 'merging' | 'success' | 'error' | 'cancelled';\n  progress: number;\n  name: string;\n  size: number;\n  uploadedChunks: number[];\n  totalChunks: number;\n  md5?: string;\n  error?: string;\n}\n\ninterface CheckFileResponse {\n  exists: boolean;\n  path?: string;\n  uploadedChunks: number[];\n}\n\ninterface MergeFileResponse {\n  success: boolean;\n  path?: string;\n}\n\nclass FileUploader {\n  // API endpoints (required) / API端点（必需）\n  private checkEndpoint: string;\n  private chunkEndpoint: string;\n  private mergeEndpoint: string;\n  \n  // Upload configuration / 上传配置\n  private chunkSize: number;\n  private concurrentFiles: number;\n  private concurrentChunks: number;\n  private maxRetries: number;\n  \n  private uploadQueue: FileItem[];\n  private uploadingCount: number;\n  private files: FileItem[];\n  \n  // 存储正在进行的请求控制器，用于取消上传\n  private abortControllers: Map<string, AbortController>;\n\n  /**\n   * Create a FileUploader instance / 创建一个FileUploader实例\n   * @param {Object} options - Configuration options / 配置选项\n   * @param {string} options.checkEndpoint - API endpoint for checking file status / 检查文件状态的API端点\n   * @param {string} options.chunkEndpoint - API endpoint for uploading chunks / 上传分片的API端点\n   * @param {string} options.mergeEndpoint - API endpoint for merging chunks / 合并分片的API端点\n   * @param {number} options.chunkSize - Size of each chunk in bytes (default: 2MB) / 每个分片的大小（默认：2MB）\n   * @param {number} options.concurrentFiles - Max concurrent file uploads (default: 3) / 最大并发文件上传数（默认：3）\n   * @param {number} options.concurrentChunks - Max concurrent chunk uploads per file (default: 3) / 每个文件的最大并发分片上传数（默认：3）\n   * @param {number} options.maxRetries - Max retry attempts for failed uploads (default: 3) / 上传失败的最大重试次数（默认：3）\n   */\n  constructor(options: FileUploaderOptions) {\n    // API endpoints (required) / API端点（必需）\n    this.checkEndpoint = options.checkEndpoint;\n    this.chunkEndpoint = options.chunkEndpoint;\n    this.mergeEndpoint = options.mergeEndpoint;\n    \n    // Validate required endpoints / 验证必需的端点\n    if (!this.checkEndpoint || !this.chunkEndpoint || !this.mergeEndpoint) {\n      throw new Error('All API endpoints (checkEndpoint, chunkEndpoint, mergeEndpoint) must be provided / 所有API端点（checkEndpoint、chunkEndpoint、mergeEndpoint）都必须提供');\n    }\n    \n    // Upload configuration / 上传配置\n    this.chunkSize = options.chunkSize || 2 * 1024 * 1024; // 2MB\n    this.concurrentFiles = options.concurrentFiles || 3;\n    this.concurrentChunks = options.concurrentChunks || 3;\n    this.maxRetries = options.maxRetries || 3;\n    \n    this.uploadQueue = [];\n    this.uploadingCount = 0;\n    this.files = [];\n    \n    // 存储正在进行的请求控制器，用于取消上传\n    this.abortControllers = new Map();\n  }\n\n  /**\n   * Add files to upload queue / 将文件添加到上传队列\n   * @param {FileList|File[]} fileList - Files to upload / 要上传的文件\n   */\n  addFiles(fileList: FileList | File[]): FileItem[] {\n    const newFiles: FileItem[] = Array.from(fileList).map((file) => ({\n      id: this.generateId(),\n      file,\n      status: 'pending', // pending, checking, uploading, merging, success, error, cancelled\n      progress: 0,\n      name: file.name,\n      size: file.size,\n      uploadedChunks: [],\n      totalChunks: Math.ceil(file.size / this.chunkSize),\n    }));\n\n    this.files = [...this.files, ...newFiles];\n    this.uploadQueue = [...this.uploadQueue, ...newFiles];\n    \n    this.processQueue();\n    \n    return newFiles;\n  }\n\n  /**\n   * Cancel file upload / 取消文件上传\n   * @param {string} fileId - ID of the file to cancel / 要取消的文件ID\n   */\n  cancelUpload(fileId: string): void {\n    const fileItem = this.files.find(item => item.id === fileId);\n    if (!fileItem) {\n      console.warn(`File with ID ${fileId} not found`);\n      return;\n    }\n\n    // 如果文件正在上传队列中，直接移除\n    if (fileItem.status === 'pending') {\n      this.uploadQueue = this.uploadQueue.filter(item => item.id !== fileId);\n      fileItem.status = 'cancelled';\n      this.updateFileStatus(fileItem);\n      return;\n    }\n\n    // 如果文件正在上传过程中，取消所有相关请求\n    if (fileItem.status === 'checking' || fileItem.status === 'uploading' || fileItem.status === 'merging') {\n      // 取消所有与该文件相关的请求\n      const abortController = this.abortControllers.get(fileId);\n      if (abortController) {\n        abortController.abort();\n        this.abortControllers.delete(fileId);\n      }\n      \n      fileItem.status = 'cancelled';\n      this.updateFileStatus(fileItem);\n      return;\n    }\n  }\n\n  /**\n   * Process upload queue / 处理上传队列\n   */\n  private processQueue(): void {\n    while (this.uploadQueue.length > 0 && this.uploadingCount < this.concurrentFiles) {\n      const fileItem = this.uploadQueue.shift();\n      if (fileItem) {\n        this.uploadingCount++;\n        this.processFile(fileItem).then(() => {\n          this.uploadingCount--;\n          this.processQueue();\n        }).catch(() => {\n          this.uploadingCount--;\n          this.processQueue();\n        });\n      }\n    }\n  }\n\n  /**\n   * Process individual file / 处理单个文件\n   * @param {Object} fileItem - File item to process / 要处理的文件项\n   */\n  private async processFile(fileItem: FileItem): Promise<void> {\n    // 为每个文件创建 AbortController\n    const abortController = new AbortController();\n    this.abortControllers.set(fileItem.id, abortController);\n    \n    try {\n      fileItem.status = 'checking';\n      this.updateFileStatus(fileItem);\n\n      // Calculate file MD5 / 计算文件MD5\n      const md5 = await this.calculateMD5(fileItem.file);\n      fileItem.md5 = md5;\n\n      // Check with server if file already exists or has partial uploads / 检查服务器上是否已存在文件或有部分上传\n      const checkResult: CheckFileResponse = await this.checkFile(fileItem.md5!, fileItem.file.name, abortController.signal);\n\n      if (checkResult.exists) {\n        // Instant transfer - file already exists / 秒传 - 文件已存在\n        fileItem.status = 'success';\n        fileItem.progress = 100;\n        this.updateFileStatus(fileItem);\n        this.abortControllers.delete(fileItem.id);\n        return;\n      }\n\n      // Identify chunks that still need to be uploaded / 识别仍需上传的分片\n      const chunksToUpload = Array.from({ length: fileItem.totalChunks }, (_, i) => i)\n        .filter(i => !checkResult.uploadedChunks.includes(i));\n\n      fileItem.uploadedChunks = checkResult.uploadedChunks;\n\n      if (chunksToUpload.length === 0) {\n        // All chunks already uploaded, just merge / 所有分片已上传，只需合并\n        await this.mergeFile(fileItem.md5!, fileItem.file.name, fileItem.totalChunks, abortController.signal);\n        fileItem.status = 'success';\n        fileItem.progress = 100;\n        this.updateFileStatus(fileItem);\n        this.abortControllers.delete(fileItem.id);\n        return;\n      }\n\n      // Upload remaining chunks / 上传剩余分片\n      fileItem.status = 'uploading';\n      this.updateFileStatus(fileItem);\n      \n      await this.uploadChunksWithConcurrency(\n        fileItem,\n        chunksToUpload,\n        abortController.signal\n      );\n\n      // Merge chunks into final file / 将分片合并为最终文件\n      fileItem.status = 'merging';\n      this.updateFileStatus(fileItem);\n      \n      await this.mergeFile(fileItem.md5!, fileItem.file.name, fileItem.totalChunks, abortController.signal);\n      \n      fileItem.status = 'success';\n      fileItem.progress = 100;\n      this.updateFileStatus(fileItem);\n      this.abortControllers.delete(fileItem.id);\n    } catch (error: any) {\n      // 检查是否是由于取消上传导致的错误\n      if (error.name === 'AbortError') {\n        fileItem.status = 'cancelled';\n        this.updateFileStatus(fileItem);\n      } else {\n        fileItem.status = 'error';\n        fileItem.error = error.message;\n        this.updateFileStatus(fileItem);\n        console.error('Upload error:', error);\n      }\n      this.abortControllers.delete(fileItem.id);\n    }\n  }\n\n  /**\n   * Upload chunks with concurrency control / 并发控制上传分片\n   * @param {Object} fileItem - File item being uploaded / 正在上传的文件项\n   * @param {number[]} chunksToUpload - Indices of chunks to upload / 要上传的分片索引\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\n   */\n  private async uploadChunksWithConcurrency(fileItem: FileItem, chunksToUpload: number[], signal: AbortSignal): Promise<void> {\n    let index = 0;\n\n    const uploadChunk = async (chunkIndex: number): Promise<void> => {\n      // 检查是否已经取消\n      if (signal.aborted) {\n        throw new DOMException('Aborted', 'AbortError');\n      }\n      \n      const start = chunkIndex * this.chunkSize;\n      const end = Math.min(start + this.chunkSize, fileItem.file.size);\n      const chunk = fileItem.file.slice(start, end);\n\n      const formData = new FormData();\n      formData.append('file', chunk);\n      formData.append('md5', fileItem.md5!);\n      formData.append('chunkIndex', chunkIndex.toString());\n      formData.append('totalChunks', fileItem.totalChunks.toString());\n\n      await this.uploadWithRetry((signal) => {\n        return fetch(this.chunkEndpoint, {\n          method: 'POST',\n          body: formData,\n          signal: signal\n        });\n      }, this.maxRetries, signal);\n\n      // Update progress / 更新进度\n      fileItem.uploadedChunks.push(chunkIndex);\n      const progress = Math.round((fileItem.uploadedChunks.length / fileItem.totalChunks) * 100);\n      fileItem.progress = progress;\n      this.updateFileStatus(fileItem);\n    };\n\n    const workers = Array.from({ length: this.concurrentChunks }, async () => {\n      while (index < chunksToUpload.length && !signal.aborted) {\n        const chunkIndex = chunksToUpload[index];\n        index++;\n        await uploadChunk(chunkIndex);\n      }\n    });\n\n    await Promise.all(workers);\n    \n    // 如果被取消，抛出异常\n    if (signal.aborted) {\n      throw new DOMException('Aborted', 'AbortError');\n    }\n  }\n\n  /**\n   * Check file status with server / 检查文件状态\n   * @param {string} md5 - File MD5 hash / 文件MD5哈希值\n   * @param {string} filename - Original filename / 原始文件名\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\n   * @returns {Promise<Object>} - Server response / 服务器响应\n   */\n  private async checkFile(md5: string, filename: string, signal: AbortSignal): Promise<CheckFileResponse> {\n    const response = await fetch(this.checkEndpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ md5, filename }),\n      signal: signal\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Request server to merge chunks / 请求服务器合并分片\n   * @param {string} md5 - File MD5 hash / 文件MD5哈希值\n   * @param {string} filename - Original filename / 原始文件名\n   * @param {number} totalChunks - Total number of chunks / 分片总数\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\n   * @returns {Promise<Object>} - Server response / 服务器响应\n   */\n  private async mergeFile(md5: string, filename: string, totalChunks: number, signal: AbortSignal): Promise<MergeFileResponse> {\n    const response = await fetch(this.mergeEndpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ md5, filename, totalChunks }),\n      signal: signal\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Upload with retry mechanism / 带重试机制的上传\n   * @param {Function} fn - Function to execute / 要执行的函数\n   * @param {number} maxRetries - Maximum retry attempts / 最大重试次数\n   * @param {AbortSignal} signal - Abort signal for cancellation / 用于取消的信号\n   * @returns {Promise<any>} - Result of function execution / 函数执行结果\n   */\n  private async uploadWithRetry(fn: (signal: AbortSignal) => Promise<Response>, maxRetries: number, signal: AbortSignal): Promise<Response> {\n    let lastError: any;\n\n    for (let i = 0; i <= maxRetries; i++) {\n      // 检查是否已经取消\n      if (signal.aborted) {\n        throw new DOMException('Aborted', 'AbortError');\n      }\n      \n      try {\n        const response = await fn(signal);\n        // 检查响应是否成功\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        return response;\n      } catch (error: any) {\n        // 如果是取消操作导致的错误，立即抛出\n        if (error.name === 'AbortError') {\n          throw error;\n        }\n        \n        lastError = error;\n\n        if (i < maxRetries) {\n          // Exponential backoff delay / 指数退避延迟\n          const delay = Math.min(1000 * Math.pow(2, i), 10000);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Calculate MD5 of file using Web Worker / 使用Web Worker计算文件MD5\n   * @param {File} file - File to calculate MD5 for / 要计算MD5的文件\n   * @returns {Promise<string>} - MD5 hash / MD5哈希值\n   */\n  private async calculateMD5(file: File): Promise<string> {\n    // Check if Web Workers are supported / 检查是否支持Web Workers\n    if (typeof Worker !== 'undefined') {\n      return new Promise((resolve, reject) => {\n        try {\n          // Create Web Worker code / 创建Web Worker代码\n          const workerCode = `\n            self.onmessage = function(event) {\n              const { file, chunkSize = 2 * 1024 * 1024 } = event.data;\n              \n              try {\n                // Dynamically import SparkMD5 / 动态导入SparkMD5\n                importScripts('https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js');\n                \n                const spark = new SparkMD5.ArrayBuffer();\n                let currentChunk = 0;\n                const totalChunks = Math.ceil(file.size / chunkSize);\n\n                function loadNextChunk() {\n                  const start = currentChunk * chunkSize;\n                  const end = Math.min(start + chunkSize, file.size);\n                  const chunk = file.slice(start, end);\n                  \n                  const reader = new FileReader();\n                  reader.onload = function(e) {\n                    spark.append(e.target.result);\n                    currentChunk++;\n                    \n                    // Send progress update / 发送进度更新\n                    const progress = Math.round((currentChunk / totalChunks) * 100);\n                    self.postMessage({ progress, type: 'progress' });\n                    \n                    if (currentChunk < totalChunks) {\n                      loadNextChunk();\n                    } else {\n                      const md5 = spark.end();\n                      self.postMessage({ md5, success: true });\n                    }\n                  };\n                  \n                  reader.onerror = function(err) {\n                    self.postMessage({ error: 'Failed to read file chunk: ' + err.message, success: false });\n                  };\n                  \n                  reader.readAsArrayBuffer(chunk);\n                }\n                \n                loadNextChunk();\n              } catch (error) {\n                self.postMessage({ error: 'Worker error: ' + error.message, success: false });\n              }\n            };\n          `;\n          \n          // Create Blob URL / 创建Blob URL\n          const blob = new Blob([workerCode], { type: 'application/javascript' });\n          const workerUrl = URL.createObjectURL(blob);\n          \n          // Create Web Worker / 创建Web Worker\n          const worker = new Worker(workerUrl);\n          \n          // Send file to Worker / 发送文件到Worker\n          worker.postMessage({\n            file: file,\n            chunkSize: this.chunkSize\n          });\n          \n          // Listen for Worker messages / 监听Worker消息\n          worker.onmessage = function(event) {\n            const data = event.data;\n            \n            if (data.type === 'progress') {\n              // Handle progress updates / 处理进度更新\n              console.log('MD5 calculation progress: ' + data.progress + '%');\n            } else if (data.success) {\n              // MD5 calculation complete / MD5计算完成\n              URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\n              resolve(data.md5);\n              worker.terminate(); // Terminate Worker / 终止Worker\n            } else {\n              // MD5 calculation error / MD5计算错误\n              URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\n              reject(new Error(data.error));\n              worker.terminate(); // Terminate Worker / 终止Worker\n            }\n          };\n          \n          // Handle Worker errors / 处理Worker错误\n          worker.onerror = function(error) {\n            URL.revokeObjectURL(workerUrl); // Release resources / 释放资源\n            reject(new Error('Worker error: ' + error.message));\n            worker.terminate(); // Terminate Worker / 终止Worker\n          };\n        } catch (error) {\n          // Fallback to main thread if Web Workers initialization fails / 如果Web Workers初始化失败则回退到主线程\n          console.warn('Failed to initialize Web Worker, falling back to main thread calculation / 无法初始化Web Worker，回退到主线程计算');\n          this.calculateMD5Fallback(file).then(resolve).catch(reject);\n        }\n      });\n    } else {\n      // Fallback to main thread if Web Workers are not supported / 如果不支持Web Workers则回退到主线程\n      console.warn('Web Workers not supported, falling back to main thread calculation / 不支持Web Workers，回退到主线程计算');\n      return this.calculateMD5Fallback(file);\n    }\n  }\n\n  /**\n   * Fallback MD5 calculation on main thread / 在主线程中回退的MD5计算\n   * @param {File} file - File to calculate MD5 for / 要计算MD5的文件\n   * @returns {Promise<string>} - MD5 hash / MD5哈希值\n   */\n  private async calculateMD5Fallback(file: File): Promise<string> {\n    // Simulate MD5 calculation on main thread / 在主线程中模拟MD5计算\n    return new Promise((resolve) => {\n      // Simulate calculation time / 模拟计算时间\n      setTimeout(() => {\n        // Simplified MD5 simulation / 简化的MD5模拟\n        resolve('md5-' + Date.now() + '-' + file.name);\n      }, 300);\n    });\n  }\n\n  /**\n   * Generate unique ID / 生成唯一ID\n   * @returns {string} - Unique ID / 唯一ID\n   */\n  private generateId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  /**\n   * Update file status callback / 更新文件状态回调\n   * Override this method to handle UI updates / 重写此方法以处理UI更新\n   * @param {Object} fileItem - Updated file item / 更新的文件项\n   */\n  updateFileStatus(fileItem: FileItem): void {\n    // This method should be overridden by the user / 此方法应由用户重写\n    console.log(`File ${fileItem.name}: ${fileItem.status} (${fileItem.progress}%)`);\n  }\n\n  /**\n   * Get current files / 获取当前文件\n   * @returns {Array} - Current files / 当前文件\n   */\n  getFiles(): FileItem[] {\n    return this.files;\n  }\n  \n  /**\n   * Clean up resources / 清理资源\n   */\n  destroy(): void {\n    // 取消所有正在进行的上传\n    for (const [fileId, controller] of this.abortControllers.entries()) {\n      controller.abort();\n    }\n    this.abortControllers.clear();\n    this.uploadQueue = [];\n    this.files = [];\n  }\n}\n\nexport default FileUploader;"],"names":["root","factory","exports","module","define","amd","this","constructor","options","checkEndpoint","chunkEndpoint","mergeEndpoint","Error","chunkSize","concurrentFiles","concurrentChunks","maxRetries","uploadQueue","uploadingCount","files","abortControllers","Map","addFiles","fileList","newFiles","Array","from","map","file","id","generateId","status","progress","name","size","uploadedChunks","totalChunks","Math","ceil","processQueue","cancelUpload","fileId","fileItem","find","item","filter","updateFileStatus","abortController","get","abort","delete","console","warn","length","shift","processFile","then","catch","AbortController","set","md5","calculateMD5","checkResult","checkFile","signal","exists","chunksToUpload","_","i","includes","mergeFile","uploadChunksWithConcurrency","error","message","index","uploadChunk","async","chunkIndex","aborted","DOMException","start","end","min","chunk","slice","formData","FormData","append","toString","uploadWithRetry","fetch","method","body","push","round","workers","Promise","all","filename","response","headers","JSON","stringify","ok","json","fn","lastError","delay","pow","resolve","setTimeout","Worker","reject","blob","Blob","type","workerUrl","URL","createObjectURL","worker","postMessage","onmessage","event","data","log","success","revokeObjectURL","terminate","onerror","calculateMD5Fallback","Date","now","random","substr","getFiles","destroy","controller","entries","clear"],"ignoreList":[],"sourceRoot":""}